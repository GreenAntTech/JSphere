class Feature{constructor(flags){this.featureFlags=[],this.featureFlags=flags}async flag(obj){for(const prop in obj){let found=!1;const flags=prop.split(",");for(const flag of flags)if(this.featureFlags.includes(flag)||"default"==flag){await obj[prop](),found=!0;break}if(found)break}}}class RenderingStatus{set document(value){this.rootElement=value}get atClient(){return"client"===this.rootElement.getAttribute("el-rendering-status")}get atServer(){return"server"===this.rootElement.getAttribute("el-rendering-status")}get loaded(){return null===this.rootElement.getAttribute("el-rendering-status")}}function isValidMessage(data){return"object"==typeof data&&null!==data&&"subject"in data&&"string"==typeof data.subject}function processEvent(event){try{const message=JSON.parse(event.data);if(!isValidMessage(message))return void console.warn("Invalid message structure:",message);const subject=message.subject,data=message.data;let listenerFound=!1;if(!registeredAllowedOrigins.includes(event.origin))return void console.warn("Message origin not registered:",event.origin);registeredDeviceMessages[subject]&&(listenerFound=!0,window.webkit?window.webkit.messageHandlers.Device.postMessage(event.data):window.Device.postMessage(event.data)),registeredMessages[subject]&&(listenerFound=!0,registeredMessages[subject](data,appContext));const children=appContext.document.querySelectorAll("[el-listening]");for(const childElement of children)childElement.listensFor$(subject)&&(listenerFound=!0,setTimeout(()=>{childElement.onMessageReceived$(subject,data)},0));listenerFound||console.warn(`No message listener was found for the subject '${subject}'`)}catch(e){console.warn("Failed to parse message:",e)}}globalThis.addEventListener("message",processEvent,!1),globalThis.addEventListener("popstate",async()=>{const href=window.location.href;for(const routePath in registeredRoutes){const route={path:routePath,handler:registeredRoutes[routePath]},pattern=new window.URLPattern({pathname:route.path});if(pattern.test(href)){const params=pattern.exec(href).pathname.groups;let path="";params[0]&&(path=params[0],delete params[0]);const searchParams=new URLSearchParams(window.location.search);for(const[key,value]of searchParams.entries())params[key]=value;await route.handler(path,params);break}}},!1);const registeredAllowedOrigins=[""],registeredCaptions={},registeredComponents={},registeredDependencies={},registeredServerDependencies={},registeredDeviceMessages={},registeredMessages={},registeredRoutes={},scriptHost={server:!!globalThis.Deno,client:!globalThis.Deno},appState={},feature=new Feature(getFeatureFlags()),renderingStatus=new RenderingStatus;let appContext={document:scriptHost.client?document:null,getResource:async path=>{const response=await fetch(path);if(200===response.status){const content=await response.text();return content}throw"File Not Found"},importModule:async url=>{try{const module=await import(url);return module}catch(e){throw console.log(e),`Either the requested resource or one of its dependencies was not found: ${url}`}}},intersectionObserver;function setAppContext(ctx){appContext={serverContext:ctx,getResource:async path=>{const file=await ctx.getPackageItem(path);if(file){const content=(new TextDecoder).decode(file.content);return content}return null},importModule:async url=>{try{const module=await import(url+`?eTag=${ctx.domain.hostname}:${ctx.domain.cacheDTS}`);return module}catch(e){throw console.log(e),`Either the requested resource or one of its dependencies was not found: ${url}`}},parser:ctx.parser}}function registerAllowedOrigin(uri){registeredAllowedOrigins.push(uri)}function registerCaptions(name,captions){registeredCaptions[name]=captions}function createComponent(param1,param2){return"string"==typeof param1?(registeredComponents[param1]=param2,param1):(registeredComponents[param1.name]=param1,param1.name)}function registerDependencies(dependencies){Object.assign(registeredDependencies,dependencies)}function registerServerDependencies(dependencies){Object.assign(registeredServerDependencies,dependencies)}function registerRoute(path,handler){void 0!==path&&"string"==typeof path?"function"==typeof handler?registeredRoutes[path]=handler:console.warn("A valid hanlder must be specified when registering a route:",handler):console.warn("A path must be specified when registering a route:",path)}function subscribeTo(subject,handler){registeredMessages[subject]=handler}function deviceSubscribesTo(subject){registeredDeviceMessages[subject]=!0}async function emitMessage(subject,data,target){if(renderingStatus.atServer){registeredMessages[subject]&&await registeredMessages[subject](data||{},appContext.serverContext);const children=appContext.document.querySelectorAll("[el-listening]");for(const childElement of children)childElement.listensFor$(subject)&&await childElement.onMessageReceived$(subject,data||{})}else{if(void 0===target&&(target=window),void 0===data&&(data={}),"function"!=typeof target.postMessage)throw"target: Must be a window object";target.postMessage(JSON.stringify({subject:subject,data:data}))}}function navigateTo(path){if(void 0===path)globalThis.dispatchEvent(new Event("popstate"));else{if(path==window.location.pathname)return;window.history.pushState({},"",path),dispatchEvent(new Event("popstate"))}}async function loadDependencies(dependencies){try{const imports=dependencies.map(dependency=>{if("component"!=dependency){const modulePath=registeredDependencies[dependency];if(!modulePath)throw new Error(`Dependency '${dependency}' not registered`);return appContext.importModule(modulePath)}});return await Promise.allSettled(imports)}catch(error){throw console.error("Failed to load dependencies:",error),error}}function getCaptions(name){return(value,...args)=>{let caption=registeredCaptions[name][value]||value;if(args&&args.length>0)for(let i=0;i<args.length;i++)caption=caption.replaceAll("$"+(i+1),args[i]);return caption}}async function renderDocument(config,ctx){if(scriptHost.server){if("object"!=typeof config)throw"renderDocument(config:object, ctx:ServerContext): Please provide a valid config object";if("object"!=typeof ctx)throw"renderDocument(config:object, ctx:ServerContext): Please provide a valid server context object";if(!config.file&&!config.html)throw"renderDocument(config:object, ctx:ServerContext): Please provide a file path to an html file OR html text - { file: '/path/to/file.html', html: '<html>...</html>' }";setAppContext(ctx);let html=config.html;if(config.file&&(html=await appContext.getResource(config.file),null===html))throw console.error("File not found:",config.file),"FileNotFound";appContext.document=appContext.parser.parseFromString(html,"text/html"),appContext.document.documentElement.setAttribute("el-rendering-status","server"),appState.request={pathname:ctx.request.url.pathname,params:ctx.request.params}}else{const params={},searchParams=new URLSearchParams(window.location.search);for(const[key,value]of searchParams.entries())params[key]=value;appState.request={pathname:window.location.pathname,hash:window.location.hash,params:params},"object"!=typeof config&&(config={}),intersectionObserver=new IntersectionObserver(async entries=>{for(const entry of entries)entry.isIntersecting&&await entry.target.hydrateOnCallback$()},{rootMargin:"100px 100px 100px 100px",threshold:0})}"object"!=typeof config.props&&(config.props={});const el=appContext.document.documentElement;renderingStatus.document=el,initElementAsComponent(el);const elId=el.getAttribute("el-id");return"root"!=elId&&el.setAttribute("el-id","root"),el.use$=()=>getRootDependencies(),renderingStatus.atServer?(await el.render$(config.props),el.setAttribute("el-rendering-status","client")):renderingStatus.atClient?(await el.hydrate$(config.props),el.removeAttribute("el-rendering-status")):(await el.render$(config.props),await el.hydrate$(config.props)),scriptHost.server?el.outerHTML:el}function getRootDependencies(){const el=appContext.document.documentElement,types=[],head=el.querySelector("head"),body=el.querySelector("body");if("client"==el.getAttribute("el-rendering-status")){const children=el.querySelectorAll('[el-parent="root"]');for(const childElement of children)types.push(childElement.getAttribute("el-is"))}else{if(head&&head.getAttribute("el-id"))types.push(head.getAttribute("el-is"));else{const children=head.querySelectorAll(":scope [el-is], [el-id]");for(const childElement of children)types.push(childElement.getAttribute("el-is"))}if(body&&body.getAttribute("el-id"))types.push(body.getAttribute("el-is"));else{const children=body.querySelectorAll(":scope [el-is], [el-id]");for(const childElement of children)types.push(childElement.getAttribute("el-is"))}}return types}!async function(){window.URLPattern||await import("./urlpattern.min.js"),window.location&&registerAllowedOrigin(window.location.origin)}();let idCount=0;function uniqueId(){return`component${idCount++}`}function initElementAsComponent(el){const tagNameMap={ul:"li",ol:"li",thead:"tr",tbody:"tr"},messageListeners={};let display,stateObject={},parent,childComponents={},hydrating=!1;Object.defineProperties(el,{define$:{value:obj=>{const componentProps={render$:{value:async props=>{if(el.renderAtClient$&&renderingStatus.atServer)return;if(el.renderAtServer$&&!renderingStatus.atServer)return;"object"!=typeof props&&(props={});const attrs={};for(const attr of el.attributes)attr.name.startsWith("data-")&&(attrs[attr.name.substring(5)]=attr.value||!0);props=Object.assign(attrs,props);const onRender=obj.onRender$;if(renderingStatus.atServer||renderingStatus.loaded){void 0===el.template$&&(el.template$=()=>{});const template=el.template$(props);el.use$&&await loadDependencies(el.use$()),template&&template.startsWith("/")?await loadTemplateUrl(el,template):await loadTemplate(el,template),onRender&&(await onRender(props),renderingStatus.atServer&&Object.keys(stateObject).length&&el.setAttribute("el-state",JSON.stringify(stateObject)))}if(renderingStatus.atClient)if(el.renderAtClient$&&onRender){const template=el.template$(props);el.use$&&await loadDependencies(el.use$()),template&&template.startsWith("/")?await loadTemplateUrl(el,template):await loadTemplate(el,template),await onRender(props)}else el.hasAttribute("el-state")&&(stateObject=JSON.parse(el.getAttribute("el-state")||"{}"),el.removeAttribute("el-state"),await loadTemplate(el));return el.children$}},hydrate$:{value:async props=>{const onHydrate=obj.onHydrate$;if(renderingStatus.atClient&&el.hasAttribute("el-hydrate-on")){const hydrateOn=el.getAttribute("el-hydrate-on");if("idle"==hydrateOn||hydrateOn.startsWith("idle:")){const time=hydrateOn.startsWith("idle:")?parseInt(hydrateOn.substring(5)):0;time&&(el.hydrateOnCallback$=async()=>{el.removeAttribute("el-hydrate-on"),el.use$&&await loadDependencies(el.use$()),await loadTemplate(el,void 0,!0),onHydrate&&await onHydrate(props)},window.requestIdleCallback(el.hydrateOnCallback$,{timeout:time}))}else if("timeout"==hydrateOn||hydrateOn.startsWith("timeout:")){const time=hydrateOn.startsWith("timeout:")?parseInt(hydrateOn.substring(5)):500;el.hydrateOnCallback$=async()=>{el.removeAttribute("el-hydrate-on"),el.use$&&await loadDependencies(el.use$()),await loadTemplate(el,void 0,!0),onHydrate&&await onHydrate(props)},setTimeout(el.hydrateOnCallback$,time)}else"visible"==hydrateOn?(el.hydrateOnCallback$=async()=>{el.removeAttribute("el-hydrate-on"),el.use$&&await loadDependencies(el.use$()),await loadTemplate(el,void 0,!0),onHydrate&&await onHydrate(props),intersectionObserver.unobserve(el)},intersectionObserver.observe(el)):(el.use$&&await loadDependencies(el.use$()),await loadTemplate(el,void 0,el.hydrating$),onHydrate&&await onHydrate(props),el.hydrating$=!1)}else renderingStatus.atClient||el.hydrating$?(el.use$&&await loadDependencies(el.use$()),await loadTemplate(el,void 0,el.hydrating$),onHydrate&&await onHydrate(props),el.hydrating$=!1):renderingStatus.loaded&&onHydrate&&await onHydrate(props);return el.children$}}};for(const prop in obj){if(!prop.endsWith("$"))throw`Invalid property name '${prop}'. Property names must end with a $.`;"function"==typeof obj[prop]?componentProps[prop]={value:obj[prop]}:componentProps[prop]=obj[prop]}Object.defineProperties(el,componentProps)}},id$:{get:()=>el.getAttribute("el-id")},is$:{get:()=>el.getAttribute("el-is")},children$:{get:()=>childComponents},hydrating$:{get:()=>hydrating,set:value=>{hydrating=value}},addAfter$:{value:async(type,elId,tagName)=>{void 0===tagName&&(tagName=el.tagName);const component=appContext.document.createElement(tagName);return component.setAttribute("el-is",type),component.setAttribute("el-id",elId),component.setAttribute("el-parent",el.parent$.id$),await loadDependencies([type]),initElementAsComponent(component),component.parent$=el.parent$,addChild(el.parent$,component),el.after(component),el.parent$.setAttribute("el-rendered","true"),component}},addBefore$:{value:async(type,elId,tagName)=>{void 0===tagName&&(tagName=el.tagName);const component=appContext.document.createElement(tagName);return component.setAttribute("el-is",type),component.setAttribute("el-id",elId),component.setAttribute("el-parent",el.parent$.id$),await loadDependencies([type]),initElementAsComponent(component),component.parent$=el.parent$,addChild(el.parent$,component),el.before(component),el.parent$.setAttribute("el-rendered","true"),component}},addFirst$:{value:async(type,elId,tagName)=>{void 0===tagName&&(tagName=tagNameMap[el.tagName.toLocaleLowerCase()]||el.tagName);const component=appContext.document.createElement(tagName);return component.setAttribute("el-is",type),component.setAttribute("el-id",elId),component.setAttribute("el-parent",el.id$),await loadDependencies([type]),initElementAsComponent(component),component.parent$=el,addChild(el,component),el.prepend(component),component}},addLast$:{value:async(type,elId,tagName)=>{void 0===tagName&&(tagName=tagNameMap[el.tagName.toLocaleLowerCase()]||el.tagName);const component=appContext.document.createElement(tagName);return component.setAttribute("el-is",type),component.setAttribute("el-id",elId),component.setAttribute("el-parent",el.id$),await loadDependencies([type]),initElementAsComponent(component),component.parent$=el,addChild(el,component),el.append(component),el.setAttribute("el-rendered","true"),component}},onMessageReceived$:{value:async(subject,data)=>{messageListeners[subject]&&await messageListeners[subject](data,appContext.ctx)}},parent$:{set:value=>{parent=value},get:()=>parent},remove$:{value:()=>{delete el.parent$.children$[el.id$],el.parent$.removeChild(el)}},removeChild$:{value:childElement=>{delete el.children$[childElement.id$],el.removeChild(childElement)}},removeChildren$:{value:()=>{childComponents={};const count=el.children.length;for(let i=count-1;i>=0;i--)el.children[i].hasAttribute("el-id")&&el.children[i].remove()}},renderAtClient$:{get:()=>"client"===el.getAttribute("el-render-at")},renderAtServer$:{get:()=>"server"===el.getAttribute("el-render-at")},listensFor$:{value:subject=>!!messageListeners[subject]},subscribeTo$:{value:(subject,handler)=>{messageListeners[subject]=handler,el.setAttribute("el-listening","true")}},state$:{get:()=>stateObject},unsubscribeTo$:{value:subject=>{delete messageListeners[subject],0===Object.keys(messageListeners).length&&el.removeAttribute("el-listening")}},captions$:{value:getCaptions},hidden$:{set:value=>{"boolean"==typeof value&&(value?("none"!==el.style.display&&(display=el.style.display),el.style.display="none"):el.style.display=display)},get:()=>"none"==el.style.display}});const type=el.getAttribute("el-is")||"component";"component"==type&&el.setAttribute("el-is","component"),registeredComponents[type]?registeredComponents[type](el):console.warn(`The component type '${type}' is not registered.`)}function getFeatureFlags(){if(scriptHost.client){const featureFlags=window.document.cookie.split("; ").find(row=>row.startsWith("featureFlags="));if(featureFlags)return featureFlags.split("=")[1].split(":")}return[]}async function loadTemplateUrl(el,url){if("string"!=typeof url)return;const template=await appContext.getResource(url);template?await loadTemplate(el,template):console.warn(`The template '${url}' could not be found.`)}async function loadTemplate(el,template,hydrating=!1){if("string"==typeof template){""!=template&&(template=sanitize(template)),el.innerHTML=template;const children=el.querySelectorAll(":scope [el-is], [el-id]");for(const childElement of children)childElement.getAttribute("el-id")||childElement.setAttribute("el-id",uniqueId()),childElement.setAttribute("el-parent",el.getAttribute("el-id")),initElementAsComponent(childElement),addChild(el,childElement);renderingStatus.atServer&&el.setAttribute("el-rendered","true")}else if(void 0===template)if(el.hasAttribute("el-rendered")){const children=el.querySelectorAll(`:scope [el-parent="${el.getAttribute("el-id")}"]`);for(const childElement of children)await loadDependencies([childElement.getAttribute("el-is")]),initElementAsComponent(childElement),childElement.hydrating$=hydrating,addChild(el,childElement)}else{const children=el.querySelectorAll(':scope [el-is], [el-id] [el-parent=""]');for(const childElement of children)childElement.getAttribute("el-id")||childElement.setAttribute("el-id",uniqueId()),childElement.setAttribute("el-parent",el.getAttribute("el-id")),initElementAsComponent(childElement),addChild(el,childElement);renderingStatus.atServer&&el.setAttribute("el-rendered","true")}}function sanitize(code){const sanitizedCode=code.replaceAll(/\?eTag=[a-zA-Z0-9:]+[\"]/g,'"').replaceAll(/\?eTag=[a-zA-Z0-9:]+[\']/g,"'");return sanitizedCode}function addChild(el,childElement){const elId=childElement.getAttribute("el-id");el.children$[elId]?Array.isArray(el.children$[elId])?el.children$[elId].push(childElement):el.children$[elId]=[el.children$[elId],childElement]:el.children$[elId]=childElement}createComponent("component",el=>{el.define$({onRender$:async props=>{for(const id in el.children$){const child=el.children$[id];await child.render$(props)}},onHydrate$:async props=>{for(const id in el.children$){const child=el.children$[id];Array.isArray(child)?child.forEach(child=>child.hydrate$(props)):await child.hydrate$(props)}}})}),createComponent("link",el=>{let _onclick;el.define$({onRender$:props=>{void 0!==props.value&&(el.text$=props.value),"boolean"==typeof props.hidden&&(el.hidden$=props.hidden),el.disabled$=props.disabled||!1,el.href$=props.href},onHydrate$:props=>{const onclick=props.onclick||(()=>{});"function"==typeof onclick&&(el.removeEventListener("click",_onclick),_onclick=event=>{event.preventDefault(),el.disabled$||!1!==onclick(event)&&(el.href$?navigateTo(el.href$):window.location.href=el.getAttribute("href"))},el.addEventListener("click",_onclick))},disabled$:{set:value=>{"boolean"==typeof value&&(value?el.setAttribute("disabled",""):el.removeAttribute("disabled"))},get:()=>el.hasAttribute("disabled")},href$:{set:value=>{"string"==typeof value&&(el.setAttribute("data-href",value),el.setAttribute("href",value))},get:()=>el.getAttribute("data-href")},text$:{set:value=>{el.textContent=value},get:()=>el.textContent}})});export{appState as appState$,createComponent as createComponent$,deviceSubscribesTo as deviceSubscribesTo$,emitMessage as emitMessage$,feature as feature$,getCaptions as useCaptions$,navigateTo as navigateTo$,registerAllowedOrigin as registerAllowedOrigin$,registerCaptions as registerCaptions$,registerDependencies as registerDependencies$,registerServerDependencies as registerServerDependencies$,registerRoute as registerRoute$,renderDocument as renderDocument$,subscribeTo as subscribeTo$};